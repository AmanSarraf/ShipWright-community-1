<!--
Copyright The Shipwright Contributors

SPDX-License-Identifier: Apache-2.0
-->

---
title: build-output-vulnerability-scanning
authors:
  - "@SaschaSchwarze0"
reviewers:
  - "@adambkaplan"
  - "@qu1queee"
approvers:
  - "@adambkaplan"
  - "@qu1queee"
creation-date: 2022-04-22
last-updated: 2022-05-12
status: implementable
---

# Build Output Vulnerability Scanning

## Release Signoff Checklist

- [x] Enhancement is `implementable`
- [x] Design details are appropriately documented from clear requirements
- [x] Test plan is defined
- [ ] Graduation criteria for dev preview, tech preview, DA
- [ ] User-facing documentation is created in [docs](/docs/)

## Summary

This ship proposes an extension to the `spec.output` of a Build or BuildRun to perform vulnerability scanning for the image that a Build produces.

## Motivation

Operating a container-based solution requires several security-relevant considerations. One of them is to run only container images that are free of security vulnerabilities.

Image vulnerability scanning starts where the image is built. With Shipwright performing that operation, Shipwright can ensure that vulnerability images are not even leaving the CI pipeline(s), by failing a BuildRun so that a vulnerable image is not even pushed to the container registry.

### Goals

- Allow a Build user to enable a vulnerability scan for the image that is built
- Allow a Build user to define that an image should not get pushed to the container registry if it is vulnerable.
- Allow a Build user to ignore certain vulnerabilities by identifier (like CVE number), or severity.

### Non-Goals

- Repeat the security scan regularly after the image was pushed to find vulnerabilities that were unknown at the time the BuildRun happened.
- Enforce the vulnerability scan for all BuildRuns through some configuration option. This can be done with policy engines that ensure that the vulnerability scan is enabled in all Builds or BuildRuns.
- Support multiple image scanning tools, or declare an interface that allows any container image scanning to be integrated with Shipwright.

### User Stories

#### Story 1

As a Shipwright user, I want to know about vulnerabilities in the images that I build.

#### Story 2

As a Shipwright user, I want to prevent vulnerable images to be pushed to my container registry.

## Proposal

### API Changes

We will extend the Build resource by an additional vulnerabilityScan section in `spec.output`:

```yaml
spec:
  output:
    vulnerabilityScan:
      enabled: true
      fail: true
      ignore:
        issues:
          - CVE-2022-12345
        severity: Low | Medium | High | Critical
        unfixed: true
```

If the `fail` flag is set to true, then validation will be performed to ensure that the build strategy uses shipwright-managed push because if the strategy would have pushed the image already, then failing the BuildRun does lead to wrong expectations. It is still possible to enable vulnerability scanning for Builds that use a strategy that pushes the image, but then `fail` must be unset or `false`.

The same fields will be made available in a BuildRun's `spec.output` and `spec.buildSpec.output`.

The BuildRun's status will be extended with vulnerability details in `status.output`:

```yaml
status:
  output:
    digest: sha256:1023103 # can only be present if the image was pushed = when fail is false
    size: 12310380
    vulnerabilities:
    - id: CVE-2022-12345
      severity: high
    - id: CVE-2021-54321
      severity: medium
```

Ignored vulnerabilities are not included here.

The list of vulnerabilities is sorted by severity and limited to 50 entries (we can make that configurable). This is done to prevent using an excessive amount of etcd storage.

Further details (where found, description, fix available) about the vulnerability will be listed in the container output only.

If the `fail` flag is set to `true` and at least one vulnerability is not ignored, then the BuildRun will fail like this:

```yaml
status:
  conditions:
  - type: Succeeded
    lastTransitionTime: ...
    status: "False"
    reason: VulnerabilitiesFound
    message: "Vulnerabilities have been found in the image. For detailed information, see kubectl --namespace NAMESPACE logs POD_NAME --container step-image-processing"
  failureDetails:
    location:
      pod: POD_NAME
      container: step-image-processing
```

### Backend

The vulnerability scanning will be performed as part of the [image-processing step that is introduced with Shipwright-managed push](0026-shipwright-managed-push.md#backend). The implementation for this ship can therefore only done after Shipwright-managed push is implemented.

Additional flags will be added to the image-processing step to pass the information from the `vulnerabilityScan` section into the step implementation.

The tool that we will use is [Trivy](https://github.com/aquasecurity/trivy). Other scanning tools were considered, and the exposed API will not contain any arguments or options that are specific to Trivy's implementation. See the [Alternatives section](#alternatives) for more information.

We will add a new base image in [images](https://github.com/shipwright-io/build/tree/main/images) that is ubi-minimal plus Trivy. This base image will be used for the image-processing step.

The command that we will run is [`trivy image`](https://aquasecurity.github.io/trivy/v0.27.1/docs/references/cli/image/).

Depending on the build strategy (strategy or shipwright managed push), the image will be scanned from the local disk (`--input` flag), or remotely (by providing `image_name`).

If the image comes from a remote registry, and `spec.output.insecure` is set to `true`, then we will add the `--insecure` flag.

If `spec.output.vulnerabilityScan.ignore.unfixed` is `true`, then we will run Trivy with the `--ignore-unfixed` flag to ignore vulnerabilities for which no fix is available.

We will run Trivy with `--format json`. The output will be analyzed by the image-processing step. Vulnerabilities will be extracted. A formatted output will be written to stdout. The vulnerability IDs and severities are set as value of the new `shp-output-vulnerabilities` result to pass the information into the TaskRun. From there, the data is stored in the BuildRun status. The serialization format is a comma-separated string (`vuln1-id:vuln1-severity,vuln2-id:vuln2-severity`) to save characters because the total number of result data is limited.

If the `fail` flag is set to `true` and a vulnerability is found that is not ignored, then the image-processing step will exit with status code 22. This is an arbitrary choice - or the 22nd letter of the alphabet is v, for vulnerable. The push operation is then not happening.

### Configuration

One nice feature of Trivy is that options can be provided using environment variables as an alternative to command line flags. This will enable Shipwright administrators to enable features like the Redis-based caching backend (`TRIVY_CACHE_BACKEND`), a custom location of the remote vulnerability database (`TRIVY_DB_REPOSITORY`), or an air-gapped mode (`TRIVY_SKIP_DB_UPDATE` and `TRIVY_OFFLINE_SCAN`) in the Shipwright configuration in the container template of the image-processing step. We can document this but will state that no API-level guarantee is given here because Trivy might change, or Shipwright might go away from Trivy.

### CLI

The new output settings will be added as flags to the appropriate CLI commands.

### Sample updates

None

### Documentation updates

The Build and BuildRun documentation are updates to explain the new fields and their behavior.

### Test Plan

The implementation has to be tested on a `unit`, `integration` and `e2e` level to ensure correctness.

## Release Criteria

## Risks and Mitigations

- Risk: Trivy might become unmaintained and outdated. Mitigation: Trivy is nowhere exposed to users. The data that we will present in the BuildRun status and in the container logs is independent of the tool. A switch to a different tool (see also [Alternatives](#alternatives)) should be possible without any problems.

## Drawbacks

## Alternatives

### Unfixed vulnerabilities

Instead of providing a flag in the Build to ignore unfixed vulnerabilities, we could also consider ignoring them always. Based on my observation, security scanning in container registries do that. Just run for example `trivy image registry.access.redhat.com/ubi8/ubi-minimal`, it lists currently 67 unfixed vulnerabilities, two of them high. On the other hand, `trivy image alpine` returns no vulnerabilities. `trivy image ubuntu:focal` finds 18 vulnerabilities but none of them high.

### Using a different tool

As an alternative to Trivy, the following tools could be considered:

- [Grype](https://github.com/anchore/grype), is not considered at the moment because it is slower (see [comparison](#performance-comparison-between-trivy-and-grype)) and I think finds less because it does not scan as much language-specific things (Go modules, node modules, etc). But in general, it is also actively maintained and improved with high velocity.
- [Clair](https://github.com/quay/clair), is not considered because its architecture is distributed and cannot run standalone.
- [Snyk](https://docs.snyk.io/), is a commercial offering with a free tier for which you also require an account setup.

### Performance comparison between Trivy and Grype

The performance comparison was done between Trivy v0.27.1 and Grype v0.35.0. Before running the tests, the local databases of the tools were updated and caches removed where available.

- Trivy: `trivy image --download-db-only && trivy image --clear-cache`
- Grype: `grype db update`

Three images were compared:

```bash
$ crane pull ghcr.io/shipwright-io/build/git:v0.9.0 image.tar
$ time trivy image --ignore-unfixed --input image.tar
real    0m3.369s
$ time grype docker-archive:image.tar --only-fixed
real    0m4.630s
```

```bash
$ crane pull maven:3.8.5-ibm-semeru-11-focal image.tar
$ time trivy image --ignore-unfixed --input image.tar
real    0m3.522s
$ time grype docker-archive:image.tar --only-fixed
real    0m7.191s
```

```bash
$ crane pull grafana/grafana:8.5.1-ubuntu image.tar
$ time trivy image --ignore-unfixed --input image.tar
real    0m2.527s
$ time grype docker-archive:image.tar --only-fixed
real    0m5.869s
```

Above measurements show that Trivy is always faster than Grype.

Given we will not have a volume to share the vulnerability database between runs, we will have to update ot more or less every time because our pre-built image will have only an up-to-date version for a few hours. Therefore, we must also compare the duration it takes to update the database. The duration strongly depends on the performance of the internet connection. The following measurement was done with a 50 MBit connection:

```bash
$ rm -rf "${HOME}/.cache/trivy/db"
$ time trivy image --download-db-only
real    0m6.633s
$ rm -rf "${HOME}/.cache/grype/db"
$ time grype db update
real    0m20.256s
```

Above measurement shows that Trivy is faster than Grype.

Note: this always downloaded the full database. During using the tools for a while, I never observed that it is sometimes faster or slower. I therefore assume that there is no incremental update.

Conclusion: in this performance comparison, Trivy was faster than Grype.

Future consideration: We can eventually support the usage of a persistent volume here. Both tools would gain from it by reusing the vulnerability database between different BuildRuns which will lead to the update not being required on every BuildRun. Also, Trivy will be again faster by using its cache. Especially in scenarios where images are rebuilt without changes to all layers will be able to use that turbo, for example Dockerfile-based builds where the `FROM` image is unchanged. But, while sharing the vulnerability database is safe, sharing the result cache can lead to problems in multi-tenant environments where the result of image scans is not intended to be shared in any way.

## Implementation History

Nothing so far.
